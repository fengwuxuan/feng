1. python commnd：ctrl + n自动补全

2. dict对象函数keys(),values() 返回的是dict_key、dict_value对象，可以支持in、迭代等操作。

3. 字符串split操作默认是以空格作为分隔符，且会清除分隔出来的空格，但是如果显式的指定空格作为分隔符，那么是不会清除分割出来的空格的。

4. #!/usr/bin/python是告诉操作系统执行这个脚本的时候，调用/usr/bin下的python解释器；

	#!/usr/bin/env python这种用法是为了防止操作系统用户没有将python装在默认的/usr/bin路径里。当系统看到这一行的时候，首先会到env设置里查找python的安装路径，再调用对应路径下的解释器程序完成操作。
   #!/usr/bin/python相当于写死了python路径;
   #!/usr/bin/env python会去环境设置寻找python目录,推荐这种写法
   
5. 指定编码格式的写法："coding[:=]\s*([-\w.]+)" 
   因此 #coding=utf-8  == #coding:utf-8 == #-*- coding:utf-8 -*-
   
6. 命令行中执行python语句：python -c command [arg] ... 一般用单引号将command括起来，避免空格的问题

7. 不带return的函数也有返回值：None

8. *args vs **kwrgs: 首先其实并不是必须写成*args 和**kwargs。 只有变量前面的 *(星号)才是必须的. 你也可以写成*var 和**vars. 而写成*args 和**kwargs只是一个通俗的命名约定。这两个是python中的可变参数。*args表示任何多个无名参数，它是一个tuple；**kwargs表示关键字参数，它是一个dict。并且同时使用*args和**kwargs时，必须*args参数列要在**kwargs前。
	*args：*args 是用来发送一个非键值对的可变数量的参数列表给一个函数.如下为例子
      def test_var_args(f_arg, *args):
         pass
      test_var_args('yasoob', 'python', 'eggs', 'test')
      那么后面三个参数即为*args。
   **kwargs：很明显允许你将不定长度的键值对, 作为参数传递给一个函数。 如果你想要在一个函数里处理带名字的参数, 你应该使用**kwargs。
      def greet_me(**kwargs):
         pass
      greet_me(name="yasoob")
   另外如果需要传递多个参数时，为了避免书写多个参数可以选择传入一个参数包：
      def test（augs）:
         a,b,c,d,e = augs
      test(zip(1,2,3,4,5))
9. 参数列表的分拆：实际就是*args和**kwargs的特殊情况，如果传入的是一个列表或者tuple，需要拆出独立的参数，前面加*即可，同理键值对加上**，例子如下：
   args = [3, 6]
   list(range(*args))
   
   d = {"voltage": "four million", "state": "bleedin' demised", "action": "VOOM"}
   func(**d)
   
10. 文档字符串、多行注释、多行字符串
    文档字符串：用于函数、类、模块的帮助文档，直接使用"""doc"""形式，模块用在开头，类和函数用在函数声明之后。
    多行注释：用法和文档字符串一致，如果需要注释多行，那么就直接用"""code"""即可
    多行字符串：当字符串一行写不下，需要写在多行时可以用多行字符串，形式和前两者一致，但是应该注意以下几点：
    1）其不能单独存在，否则会被当成注释或者文档，需作为参数或者变量赋值
    2）换行时需要加上\，否则会自动加上\n，此外\与字符串之间的空格会被当成字符处理。
    
11. 函数注解：是关于用户自定义的函数的完全可选的、随意的元数据信息。无论 Python 本身或者标准库中都没有使用函数注解；第三方的项目是自由地为文档，类型检查，以及其它用途选择函数注解。注解是以字典形式存储在函数的 __annotations__ 属性中，对函数的其它部分没有任何影响。如下是带有函数注解的函数定义方式。但是貌似在python3.5中已经不这么写了
    def f(ham: 42, eggs: int = 'spam') -> "Nothing to see here":

12. PEP8代码推荐风格：

13. 数据结构部分：(x代表元素、L表示列表、i表示索引位置、python中函数参数内的[]有时表示是可选的意思，比如pop,k表示key，v表示value，im表示item)
   1）list列表：
      （1）原理：基于PyListObject实现，列表支持元素的插入、删除、更新操作，因此PyListObject是一个变长对象（列表的长度随着元素的增加和删除而变长和变短），同时它还是一个可变对象（列表中的元素根据列表的操作而发生变化，内存大小动态的变化），PyListObject的定义：
         typedef struct {
            # 列表对象引用计数
            int ob_refcnt;  
            # 列表类型对象,所有对象都继承于同一个基类，列表里存放指针就好，然后利用meta数据得到类型。这就是它支持不同对象的原理。
            struct _typeobject *ob_type;
            # 列表元素的长度
            int ob_size; /* Number of items in variable part */
            # 真正存放列表元素容器的指针，list[0] 就是 ob_item[0],和C++的vector原理一样，维护一个数组，当长度不够的时候扩充长度。
            PyObject **ob_item;
            # 当前列表可容纳的元素大小
            Py_ssize_t allocated;
         } PyListObject;
         ob_item是真正存放列表元素容器的指针，专门有一块内存用来存储列表元素，这块内存的大小就是allocated所能容纳的空间。
      （2）方法：append(x)、pop([i])、extend(L)(等于+)、copy（浅拷贝，等于a[:]）、clear、insert(i,x)、remove(x)、sort()、index(x)、count(x)、reverse（），值得注意的是insert、sort、reverse这些函数返回的是None，可能对别的语言来说会返回一个可变的对象（变化后的对象），但是python中对可变对象来说是不返回的，这是一个统一的设计原则。
      （3）作为堆栈使用：从append和pop来看，它完全可以当做堆栈来做，它维护的是一个数组，所以在末端插入删除是很方便的
      （4）作为队列使用：可以是可以，但是效率比较差，毕竟插入还好说，但是出队后要将后面的元素迁移，效率较差，真要使用可以采用collections里面的队列。
      （5）列表推导式：可以用list(推导式)或[推导式的形式]
   2）del语句：删除对象，可以删除列表、dict等支持item deletion的数据结构，注意tuple是不支持的，使用del a[0], del b[key],可以帮助清空整个列表或者直接删除列表。
   3) tuple元组：python中元组可以不加括号，只要是逗号分隔的多个元素都可以被当成是一个元组，即使只有一个元素也必须要加逗号，不然分不清是单个变量还是元组，tuple是不可变的，他不支持增删，这也是为什么它不支持del的原因。另外他是无序的，也不支持排序。
      （1）原理：可以看成是特殊的list
      （2）方法：由于不支持增删，因此只有两个函数count、index
      （3）与list相比：虽然是不可变的，没有list灵活，但是有如下优点：
         创建：创建的开销比list小十倍，遍历的速度差不多
         空间：tuple所用空间更小
         可哈希：tuple是可哈希的，因此可以作为dict的key，但是list不行
         安全性：由于不可变，意味着多线程安全，不需要锁，不担心被恶意修改或者不小心修改。
         此外tuple类型对于Python自身来说是非常重要的数据类型，比如说函数调用，实际上会将顺序传入的参数先组成一个tuple；多返回值也是靠返回一个tuple来实现的。
   4）set集合：是一个无序不重复元素的集，与dict（有序重复覆盖）不同，所以多用于关系测试和消除重复元素，不支持索引操作的哦。支持迭代
      （1）原理：python中的set基于哈希表实现，存取时间可看做O(1)，但是没有办法高效的完成顺序相关的操作(比如找前驱后继，最大最小值等等)，所以认为是“无序”的。而其他语言用平衡二叉树实现的set(如c++中用红黑树实现的set和python中的orderedset)，所以有前驱和后继，是有序的。python的实现有点在于查找速度快。
      （2）方法：add（x）(添加元素)、clear、copy、difference（求差集）、difference_update(求差集并更新为自己)、intersection(交集)、union(并集)及update操作、discard(x)(删除元素)、pop、remove（x）、issubset、isdisjoint
   5）dict字典：可以看做是无序的键值对集合，实现方式与dict是一致的。
      （1）原理：字典中的一个key-value键值对元素称为entry（也叫做slots），对应到Python内部是PyDictEntry，PyDictObject就是PyDictEntry的集合。PyDictEntry的定义是：
         typedef struct {
          Py_ssize_t me_hash;
          PyObject *me_key;
          PyObject *me_value;
         } PyDictEntry;
       me_hash用于缓存me_key的哈希值，防止每次查询时都要计算哈希值，entry有三种状态：unused、active、dummy（删除元素后由active变成dummy）
      （2）方法：clear、copy、fromkeys、get(k)、has_key（k）、items、iteritems、iterkeys、itervalues（返回迭代器）、keys、pop（key）、popitem、setdefault（key）、update、values、viewitems、viewkeys、viewvalues（返回dict_key/value/item对象，不支持往下的操作）。
   6）私有方法：
14. 循环技巧
   1）在字典中循环时，关键字和对应的值可以使用 items() 方法同时解读出来:
   2）在序列中循环时，索引位置和对应值可以使用 enumerate() 函数同时得到，字典和集合不行哦
   3）同时循环两个或更多的序列，可以使用 zip() 整体打包：for q, a in zip(questions, answers):
15. 模块方法：
   1）模块名：从全局变量__name__获得。这个变量主要被用来区分一个模块文件时主动执行还是被动调用执行，如果是主动执行(__name__=="__main__")那么它的值就是__main__，否则就是模块名。被动执行的时候模块中带有定义的代码是不会被执行的（def、class等），但是如果直接在外部写了一条print语句是会被执行的，另外main里面也不会被执行。
   2）模块开始部分往往会包含一些可执行语句，用于初始化模块。
   3）每个模块都有自己私有的符号表，被模块内所有的函数定义作为全局符号表使用。因此，模块的作者可以在模块内部使用全局变量，而无需担心它与某个用户的全局变量意外冲突。从另一个方面讲，如果你确切的知道自己在做什么，你可以使用引用模块函数的表示法访问模块的全局变量
   4）from test import *：可以导入除了以_开头命名的函数和类，但是导入的速度会变慢且代码可读性变差。
   5）出于性能考虑，每个模块在每个解释器会话中只导入一遍。因此，如果你修改了你的模块，需要重启解释器；或者，如果你就是想交互式的测试这么一个模块，可以用 imp.reload() 重新加载，一般在ipython中用的较多。
   6）作为脚本来执行模块：用如下方式运行python fibo.py <arguments>，__name__会被置为__main__，进而主动运行，通常来说这个是为了方便测试。
   7）模块搜索路径：解释器由 sys.path 变量指定的路径目录搜索模块，该变量初始化时默认包含了输入脚本（或者当前目录）， PYTHONPATH 和安装目录。这样就允许 Python 程序了解如何修改或替换模块搜索目录。需要注意的是由于这些目录中包含有搜索路径中运行的脚本，所以这些脚本不应该和标准模块重名，否则在导入模块时 Python 会尝试把这些脚本当作模块来加载。这通常会引发错误。
      输入脚本的目录（当前目录）。
      环境变量 PYTHONPATH 表示的目录列表中搜索
      Python 默认安装路径中搜索。
   8）编译后的python文件：为了加快加载模块的速度，Python 会在 __pycache__ 目录下以 module.version.pyc 名字缓存每个模块编译后的版本，这里的版本编制了编译后文件的格式。它通常会包含 Python 的版本号。Python 会检查源文件与编译版的修改日期以确定它是否过期并需要重新编译。这是完全自动化的过程。同时，编译后的模块是跨平台的，所以同一个库可以在不同架构的系统之间共享。
      Python 不检查在两个不同环境中的缓存。首先，它会永远重新编译而且不会存储直接从命令行加载的模块。其次，如果没有源模块它不会检查缓存。若要支持没有源文件（只有编译版）的发布，编译后的模块必须在源目录下，并且必须没有源文件的模块。
      高级技巧：
      为了减少一个编译模块的大小，你可以在 Python 命令行中使用 -O 或者 -OO。-O 参数删除了断言语句，-OO 参数删除了断言语句和 __doc__ 字符串。
      来自 .pyc 文件或 .pyo 文件中的程序不会比来自 .py 文件的运行更快；.pyc 或 .pyo 文件只是在它们加载的时候更快一些。
      compileall 模块可以为指定目录中的所有模块创建 .pyc 文件
   9）包：包通常是使用用“包名圆点基本语法是通过 {} 和 : 来代替以前的 % 。块名”的结构化模块命名空间。A.B，为了让 Python 将目录当做内容包，目录中必须包含 __init__.py 文件。这是为了避免一个含有烂俗名字的目录无意中隐藏了稍后在模块搜索路径中出现的有效模块。最简单的情况下，只需要一个空的 __init__.py 文件即可。当然它也可以执行包的初始化代码，或者定义稍后介绍的 __all__ 变量。
     from 包.test import *：（test是一个子包），这可能会花掉很长时间，并且出现期待之外的边界效应，导出了希望只能显式导入的包。因此需要在每个文件内设置需要导出的函数或者在__init__.py文件中设置要被导出的模块，这就是__all__的作用，它是一个列表。
     包内引用：子包可以按相对路径(. ..)或者绝对路径（父包.相邻包）来引用其他包
     多重目录中的包：包支持一个更为特殊的特性， __path__。 在包的 __init__.py 文件代码执行之前，该变量初始化一个目录名列表。该变量可以修改，它作用于包中的子包和模块的搜索功能。默认情况下只有一个元素, 就是当前包的路径, 修改__path__, 可以修改此包内的搜索路径. 
  10）dir()内置函数：用于按模块名搜索模块定义，它返回一个字符串类型的存储列表，不带参数时，返回当前范围内的变量、方法和定义的类型列表；带参数时，返回参数的属性、方法列表。
   
16. 函数：
   1）如果频繁的使用一个函数，可以将它赋给一个本地变量，这样可以提高效率。
   2）

17. 输入输出
   1）格式控制：format vs %, 现在主流是format
      （1）format：基本语法是通过 {} 和 : 来代替以前的 % 。format 函数可以接受不限个参数，位置可以不按顺序，str可以包含控制字符串和其他字符串。{}用于控制位置以及参数，：用于控制格式字符串
           >>>"{} {}".format("hello", "world")    # 不设置指定位置，按默认顺序
            'hello world'
           >>> "{0} {1}".format("hello", "world")  # 设置指定位置
            'hello world'
           >>> "{1} {0} {1}".format("hello", "world")  # 设置指定位置
            'world hello world'
           print("网站名：{name}, 地址 {url}".format(name="菜鸟教程", url="www.runoob.com")) #指定参数，也可以组织成字典，然后用**dict传进来，
组织为列表，用*list传进来（参考*args，**kwargs），也可以像str.format传入对象。
           数字格式化形式：小数3.1415926，整数5，注意小数不能在这里转化为整数，大数10000000，小数0.25
            {:.2f} -->3.14    #小数点后两位
            {:+.2f} -->+3.14  #保留符号
            {:02d}   05   #左补0
            {:0>2d}  05   #左补0
            {:0<2d}  50   #右补0
            {:,}    10,000,000 #逗号分隔
            {:.2e}  1.00e+7   #科学计数法，并限制小数点后的位数
            {:.2%}  25.00%  #百分制，且限制小数点后的位数
            {:10d}  右对齐
            {:<10d} 左对齐
            {:^10d} 中间对齐
            进制b、d、o、x、#x、#X
        （2）%是老版的方法，其作用和用法与format一致，不同的是{：}用%替换，format也用%替换，其形式为str%obj
     2) str vs repr:函数 str() 用于将值转化为适于人阅读的形式，而 repr() 转化为供解释器读取的形式,某对象没有适于人阅读的解释形式的话，str() 会返回与 repr() 等同的值。
	 3）文件读写：文件对象f，f.read(size),list(f)









