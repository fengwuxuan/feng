1. python commnd：ctrl + n自动补全

2. dict对象函数keys(),values() 返回的是dict_key、dict_value对象，可以支持in、迭代等操作。

3. 字符串split操作默认是以空格作为分隔符，且会清除分隔出来的空格，但是如果显式的指定空格作为分隔符，那么是不会清除分割出来的空格的。

4. #!/usr/bin/python是告诉操作系统执行这个脚本的时候，调用/usr/bin下的python解释器；

	#!/usr/bin/env python这种用法是为了防止操作系统用户没有将python装在默认的/usr/bin路径里。当系统看到这一行的时候，首先会到env设置里查找python的安装路径，再调用对应路径下的解释器程序完成操作。
   #!/usr/bin/python相当于写死了python路径;
   #!/usr/bin/env python会去环境设置寻找python目录,推荐这种写法
   
5. 指定编码格式的写法："coding[:=]\s*([-\w.]+)" 
   因此 #coding=utf-8  == #coding:utf-8 == #-*- coding:utf-8 -*-
   
6. 命令行中执行python语句：python -c command [arg] ... 一般用单引号将command括起来，避免空格的问题

7. 不带return的函数也有返回值：None

8. *args vs **kwrgs: 首先其实并不是必须写成*args 和**kwargs。 只有变量前面的 *(星号)才是必须的. 你也可以写成*var 和**vars. 而写成*args 和**kwargs只是一个通俗的命名约定。这两个是python中的可变参数。*args表示任何多个无名参数，它是一个tuple；**kwargs表示关键字参数，它是一个dict。并且同时使用*args和**kwargs时，必须*args参数列要在**kwargs前。
	*args：*args 是用来发送一个非键值对的可变数量的参数列表给一个函数.如下为例子
      def test_var_args(f_arg, *args):
         pass
      test_var_args('yasoob', 'python', 'eggs', 'test')
      那么后面三个参数即为*args。
   **kwargs：很明显允许你将不定长度的键值对, 作为参数传递给一个函数。 如果你想要在一个函数里处理带名字的参数, 你应该使用**kwargs。
      def greet_me(**kwargs):
         pass
      greet_me(name="yasoob")
   另外如果需要传递多个参数时，为了避免书写多个参数可以选择传入一个参数包：
      def test（augs）:
         a,b,c,d,e = augs
      test(zip(1,2,3,4,5))
9. 参数列表的分拆：实际就是*args和**kwargs的特殊情况，如果传入的是一个列表或者tuple，需要拆出独立的参数，前面加*即可，同理键值对加上**，例子如下：
   args = [3, 6]
   list(range(*args))
   
   d = {"voltage": "four million", "state": "bleedin' demised", "action": "VOOM"}
   func(**d)
   
10. 文档字符串、多行注释、多行字符串
    文档字符串：用于函数、类、模块的帮助文档，直接使用"""doc"""形式，模块用在开头，类和函数用在函数声明之后。
    多行注释：用法和文档字符串一致，如果需要注释多行，那么就直接用"""code"""即可
    多行字符串：当字符串一行写不下，需要写在多行时可以用多行字符串，形式和前两者一致，但是应该注意以下几点：
    1）其不能单独存在，否则会被当成注释或者文档，需作为参数或者变量赋值
    2）换行时需要加上\，否则会自动加上\n，此外\与字符串之间的空格会被当成字符处理。
    
11. 函数注解：是关于用户自定义的函数的完全可选的、随意的元数据信息。无论 Python 本身或者标准库中都没有使用函数注解；第三方的项目是自由地为文档，类型检查，以及其它用途选择函数注解。注解是以字典形式存储在函数的 __annotations__ 属性中，对函数的其它部分没有任何影响。如下是带有函数注解的函数定义方式。但是貌似在python3.5中已经不这么写了
    def f(ham: 42, eggs: int = 'spam') -> "Nothing to see here":

12. PEP8代码推荐风格：

13. 数据结构部分：(x代表元素、L表示列表、i表示索引位置、python中函数参数内的[]有时表示是可选的意思，比如pop,k表示key，v表示value，im表示item)
   1）list列表：
      （1）原理：基于PyListObject实现，列表支持元素的插入、删除、更新操作，因此PyListObject是一个变长对象（列表的长度随着元素的增加和删除而变长和变短），同时它还是一个可变对象（列表中的元素根据列表的操作而发生变化，内存大小动态的变化），PyListObject的定义：
         typedef struct {
            # 列表对象引用计数
            int ob_refcnt;  
            # 列表类型对象,所有对象都继承于同一个基类，列表里存放指针就好，然后利用meta数据得到类型。这就是它支持不同对象的原理。
            struct _typeobject *ob_type;
            # 列表元素的长度
            int ob_size; /* Number of items in variable part */
            # 真正存放列表元素容器的指针，list[0] 就是 ob_item[0],和C++的vector原理一样，维护一个数组，当长度不够的时候扩充长度。
            PyObject **ob_item;
            # 当前列表可容纳的元素大小
            Py_ssize_t allocated;
         } PyListObject;
         ob_item是真正存放列表元素容器的指针，专门有一块内存用来存储列表元素，这块内存的大小就是allocated所能容纳的空间。
      （2）方法：append(x)、pop([i])、extend(L)(等于+)、copy（浅拷贝，等于a[:]）、clear、insert(i,x)、remove(x)、sort()、index(x)、count(x)、reverse（），值得注意的是insert、sort、reverse这些函数返回的是None，可能对别的语言来说会返回一个可变的对象（变化后的对象），但是python中对可变对象来说是不返回的，这是一个统一的设计原则。
      （3）作为堆栈使用：从append和pop来看，它完全可以当做堆栈来做，它维护的是一个数组，所以在末端插入删除是很方便的
      （4）作为队列使用：可以是可以，但是效率比较差，毕竟插入还好说，但是出队后要将后面的元素迁移，效率较差，真要使用可以采用collections里面的队列。
      （5）列表推导式：可以用list(推导式)或[推导式的形式]
   2）del语句：删除对象，可以删除列表、dict等支持item deletion的数据结构，注意tuple是不支持的，使用del a[0], del b[key],可以帮助清空整个列表或者直接删除列表。
   3) tuple元组：python中元组可以不加括号，只要是逗号分隔的多个元素都可以被当成是一个元组，即使只有一个元素也必须要加逗号，不然分不清是单个变量还是元组，tuple是不可变的，他不支持增删，这也是为什么它不支持del的原因。另外他是无序的，也不支持排序。
      （1）原理：可以看成是特殊的list
      （2）方法：由于不支持增删，因此只有两个函数count、index
      （3）与list相比：虽然是不可变的，没有list灵活，但是有如下优点：
         创建：创建的开销比list小十倍，遍历的速度差不多
         空间：tuple所用空间更小
         可哈希：tuple是可哈希的，因此可以作为dict的key，但是list不行
         安全性：由于不可变，意味着多线程安全，不需要锁，不担心被恶意修改或者不小心修改。
         此外tuple类型对于Python自身来说是非常重要的数据类型，比如说函数调用，实际上会将顺序传入的参数先组成一个tuple；多返回值也是靠返回一个tuple来实现的。
   4）set集合：是一个无序不重复元素的集，与dict（有序重复覆盖）不同，所以多用于关系测试和消除重复元素，不支持索引操作的哦。支持迭代
      （1）原理：python中的set基于哈希表实现，存取时间可看做O(1)，但是没有办法高效的完成顺序相关的操作(比如找前驱后继，最大最小值等等)，所以认为是“无序”的。而其他语言用平衡二叉树实现的set(如c++中用红黑树实现的set和python中的orderedset)，所以有前驱和后继，是有序的。python的实现有点在于查找速度快。
      （2）方法：add（x）(添加元素)、clear、copy、difference（求差集）、difference_update(求差集并更新为自己)、intersection(交集)、union(并集)及update操作、discard(x)(删除元素)、pop、remove（x）、issubset、isdisjoint
   5）dict字典：可以看做是无序的键值对集合，实现方式与dict是一致的。
      （1）原理：字典中的一个key-value键值对元素称为entry（也叫做slots），对应到Python内部是PyDictEntry，PyDictObject就是PyDictEntry的集合。PyDictEntry的定义是：
         typedef struct {
          Py_ssize_t me_hash;
          PyObject *me_key;
          PyObject *me_value;
         } PyDictEntry;
       me_hash用于缓存me_key的哈希值，防止每次查询时都要计算哈希值，entry有三种状态：unused、active、dummy（删除元素后由active变成dummy）
      （2）方法：clear、copy、fromkeys、get(k)、has_key（k）、items、iteritems、iterkeys、itervalues（返回迭代器）、keys、pop（key）、popitem、setdefault（key）、update、values、viewitems、viewkeys、viewvalues（返回dict_key/value/item对象，不支持往下的操作）。
   6）私有方法：
14. 循环技巧
   1）在字典中循环时，关键字和对应的值可以使用 items() 方法同时解读出来:
   2）在序列中循环时，索引位置和对应值可以使用 enumerate() 函数同时得到，字典和集合不行哦
   3）同时循环两个或更多的序列，可以使用 zip() 整体打包：for q, a in zip(questions, answers):
15. 模块方法：
   1）模块名：从全局变量__name__获得。这个变量主要被用来区分一个模块文件时主动执行还是被动调用执行，如果是主动执行(__name__=="__main__")那么它的值就是__main__，否则就是模块名。被动执行的时候模块中带有定义的代码是不会被执行的（def、class等），但是如果直接在外部写了一条print语句是会被执行的，另外main里面也不会被执行。
   2）模块开始部分往往会包含一些可执行语句，用于初始化模块。
   3）每个模块都有自己私有的符号表，被模块内所有的函数定义作为全局符号表使用。因此，模块的作者可以在模块内部使用全局变量，而无需担心它与某个用户的全局变量意外冲突。从另一个方面讲，如果你确切的知道自己在做什么，你可以使用引用模块函数的表示法访问模块的全局变量
   4）from test import *：可以导入除了以_开头命名的函数和类，但是导入的速度会变慢且代码可读性变差。
   5）出于性能考虑，每个模块在每个解释器会话中只导入一遍。因此，如果你修改了你的模块，需要重启解释器；或者，如果你就是想交互式的测试这么一个模块，可以用 imp.reload() 重新加载，一般在ipython中用的较多。
   6）作为脚本来执行模块：用如下方式运行python fibo.py <arguments>，__name__会被置为__main__，进而主动运行，通常来说这个是为了方便测试。
   7）模块搜索路径：解释器由 sys.path 变量指定的路径目录搜索模块，该变量初始化时默认包含了输入脚本（或者当前目录）， PYTHONPATH 和安装目录。这样就允许 Python 程序了解如何修改或替换模块搜索目录。需要注意的是由于这些目录中包含有搜索路径中运行的脚本，所以这些脚本不应该和标准模块重名，否则在导入模块时 Python 会尝试把这些脚本当作模块来加载。这通常会引发错误。
      输入脚本的目录（当前目录）。
      环境变量 PYTHONPATH 表示的目录列表中搜索
      Python 默认安装路径中搜索。
   8）编译后的python文件：为了加快加载模块的速度，Python 会在 __pycache__ 目录下以 module.version.pyc 名字缓存每个模块编译后的版本，这里的版本编制了编译后文件的格式。它通常会包含 Python 的版本号。Python 会检查源文件与编译版的修改日期以确定它是否过期并需要重新编译。这是完全自动化的过程。同时，编译后的模块是跨平台的，所以同一个库可以在不同架构的系统之间共享。
      Python 不检查在两个不同环境中的缓存。首先，它会永远重新编译而且不会存储直接从命令行加载的模块。其次，如果没有源模块它不会检查缓存。若要支持没有源文件（只有编译版）的发布，编译后的模块必须在源目录下，并且必须没有源文件的模块。
      高级技巧：
      为了减少一个编译模块的大小，你可以在 Python 命令行中使用 -O 或者 -OO。-O 参数删除了断言语句，-OO 参数删除了断言语句和 __doc__ 字符串。
      来自 .pyc 文件或 .pyo 文件中的程序不会比来自 .py 文件的运行更快；.pyc 或 .pyo 文件只是在它们加载的时候更快一些。
      compileall 模块可以为指定目录中的所有模块创建 .pyc 文件
   9）包：包通常是使用用“包名圆点基本语法是通过 {} 和 : 来代替以前的 % 。块名”的结构化模块命名空间。A.B，为了让 Python 将目录当做内容包，目录中必须包含 __init__.py 文件。这是为了避免一个含有烂俗名字的目录无意中隐藏了稍后在模块搜索路径中出现的有效模块。最简单的情况下，只需要一个空的 __init__.py 文件即可。当然它也可以执行包的初始化代码，或者定义稍后介绍的 __all__ 变量。
     from 包.test import *：（test是一个子包），这可能会花掉很长时间，并且出现期待之外的边界效应，导出了希望只能显式导入的包。因此需要在每个文件内设置需要导出的函数或者在__init__.py文件中设置要被导出的模块，这就是__all__的作用，它是一个列表。
     包内引用：子包可以按相对路径(. ..)或者绝对路径（父包.相邻包）来引用其他包
     多重目录中的包：包支持一个更为特殊的特性， __path__。 在包的 __init__.py 文件代码执行之前，该变量初始化一个目录名列表。该变量可以修改，它作用于包中的子包和模块的搜索功能。默认情况下只有一个元素, 就是当前包的路径, 修改__path__, 可以修改此包内的搜索路径. 
  10）dir()内置函数：用于按模块名搜索模块定义，它返回一个字符串类型的存储列表，不带参数时，返回当前范围内的变量、方法和定义的类型列表；带参数时，返回参数的属性、方法列表。
   
16. 函数：
   1）如果频繁的使用一个函数，可以将它赋给一个本地变量，这样可以提高效率。
   2）

17. 输入输出
   1）格式控制：format vs %, 现在主流是format
      （1）format：基本语法是通过 {} 和 : 来代替以前的 % 。format 函数可以接受不限个参数，位置可以不按顺序，str可以包含控制字符串和其他字符串。{}用于控制位置以及参数，：用于控制格式字符串
           >>>"{} {}".format("hello", "world")    # 不设置指定位置，按默认顺序
            'hello world'
           >>> "{0} {1}".format("hello", "world")  # 设置指定位置
            'hello world'
           >>> "{1} {0} {1}".format("hello", "world")  # 设置指定位置
            'world hello world'
           print("网站名：{name}, 地址 {url}".format(name="菜鸟教程", url="www.runoob.com")) #指定参数，也可以组织成字典，然后用**dict传进来，
组织为列表，用*list传进来（参考*args，**kwargs），也可以像str.format传入对象。
           数字格式化形式：小数3.1415926，整数5，注意小数不能在这里转化为整数，大数10000000，小数0.25
            {:.2f} -->3.14    #小数点后两位
            {:+.2f} -->+3.14  #保留符号
            {:02d}   05   #左补0
            {:0>2d}  05   #左补0
            {:0<2d}  50   #右补0
            {:,}    10,000,000 #逗号分隔
            {:.2e}  1.00e+7   #科学计数法，并限制小数点后的位数
            {:.2%}  25.00%  #百分制，且限制小数点后的位数
            {:10d}  右对齐
            {:<10d} 左对齐
            {:^10d} 中间对齐
            进制b、d、o、x、#x、#X
        （2）%是老版的方法，其作用和用法与format一致，不同的是{：}用%替换，format也用%替换，其形式为str%obj
     2) str vs repr:函数 str() 用于将值转化为适于人阅读的形式，而 repr() 转化为供解释器读取的形式,某对象没有适于人阅读的解释形式的话，str() 会返回与 repr() 等同的值。
	 3）文件读写：文件对象f，f.read(size),list(f)
18. 错误与异常：
    1）捕捉：try ... except Exception ... else ... 或者 try ... except Exception ... finally ... 
    2）抛出： raise 异常对象或者错误对象
    3）异常：需要继承基类Exception，并实现__init__与__str__接口。
       class MyError(Exception):
	  def __init__(self, value):
            self.value = value
         def __str__(self):
            return repr(self.value)
    4）错误：Error是所有错误的基类，它继承自Exception。所有错误需要继承它，实现__init__接口并传入message
       class MyError(error):
           def __init__(self,others,message):
	       self.others = others
	       self.message = message

19. 类
    1）Python 的类并没有在用户和定义之间设立绝对的屏障，而是依赖于用户不去“强行闯入定义”的优雅。另一方面，类的大多数重要特性都被完整的保留下来：类继承机制允许多重继承，派生类可以覆盖（override）基类中的任何方法或类，可以使用相同的方法名称调用基类的方法。对象可以包含任意数量的私有数据。
    2）作用域与命名空间：命名空间 是从命名到对象的映射。当前命名空间主要是通过 Python 字典实现的，不过通常不关心具体的实现方式（除非出于性能考虑），以后也有可能会改变其实现方式。比如Python的built-in names（包括内置函数，内置常量，内置类型）；一个模块的global names（这个模块定义的函数，类，变量）；一个函数的所有local names；还有一个类对象的所有属性（数据成员，成员函数）都组成一个命名空间。Python 中任何一个“.”之后的命名为属性，之前的部分可以看做是一个命名空间，从模块中引用命名是引用属性，因此，模块的属性和模块中的全局命名有直接的映射关系：它们共享同一命名空间！命名空间都是有创建时间和生存期的。对于Python built-in names组成的命名空间，它在Python解释器启动的时候被创建，在解释器退出的时候才被删除；对于一个Python模块的global namespace，它在这个module被import的时候创建，在解释器退出的时候退出；对于一个函数的local namespace，它在函数每次被调用的时候创建，函数返回的时候被删除。注：一个模块的引入，函数的调用，类的定义都会引入命名空间，函数中的再定义函数，类中的成员函数定义会在局部namespace中再次引入局部namespace。
       作用域是Python程序（文本）的某一段或某些段，在这些地方，某个命名空间中的名字可以被直接引用，这个作用域就是这个命名空间的作用域。尽管作用域是静态定义，在使用时他们都是动态的。一个程序的作用域有：
        a）最里面的局部作用域
        b）外层函数的局部作用域
        c）模块的全局作用域
        d）包含Python内置对象的最外层作用域
        每次执行时，至少有三个命名空间和可以直接访问的作用域嵌套在一起：
        包含局部命名的使用域在最里面，首先被搜索；其次搜索的是中层的作用域，这里包含了同级的函数；最后搜索最外面的作用域，它包含内置命名。
        首先搜索最内层的作用域，它包含局部命名任意函数包含的作用域，是内层嵌套作用域搜索起点，包含非局部，但是也非全局的命名
        接下来的作用域包含当前模块的全局命名
        最外层的作用域（最后搜索）是包含内置命名的命名空间
       
       赋值操作再理解：赋值操作不会拷贝，只是把名字和对象做一个绑定。也就是赋值语句是起一个绑定或重绑定的作用（bind or rebind）。函数调用的参数传递是赋值，不是拷贝。
       global和nonlocal语句：global语句用来声明一系列变量，这些变量会引用到当前模块的全局命名空间的变量（module－level namespace），如果该变量没有定义，也会在全局空间中添加这个变量。Python 的一个特别之处在于：如果没有使用 global 语法，其赋值操作总是在最里层的作用域。赋值不会复制数据，只是将命名绑定到对象。删除也是如此：del x 只是从局部作用域的命名空间中删除命名 x。
        而nonlocal语句用来声明一系列的变量，这个声明会从声明处从里到外的namespace去搜寻这个变量（the nearest enclosing scope），直到模块的全局域（不包括全局域），找到了则引用这个命名空间的这个名字和对象，若作赋值操作，则直接改变外层域中的这个名字的绑定。nonlocal语句声明的变量不会在当前scope的namespace字典中加入一个key-value对，如果在外层域中没有找到，则如下报错。
    3）类变量与实例变量：类内通过self定义的变量是实例变量，否则是类变量。另外self仅仅是一个约定，在python中没有任何意义，只是改变的话对他人来说可读性会变差。
    4）继承：Python 有两个用于继承的函数：函数 isinstance() 用于检查实例类型，函数 issubclass() 用于检查类继承。派生类定义的执行过程和基类是一样的。构造派生类对象时，就记住了基类。这在解析属性引用的时候尤其有用：如果在类中找不到请求调用的属性，就搜索基类。如果基类是由别的类派生而来，这个规则会递归的应用上去。派生类可能会覆盖其基类的方法。因为方法调用同一个对象中的其它方法时没有特权，基类的方法调用同一个基类的方法时，可能实际上最终调用了派生类中的覆盖方法。（对于 C++ 程序员来说，Python 中的所有方法本质上都是 虚 方法。）
    5）内置属性：
    __dict__ : 类的属性（包含一个字典，由类的数据属性组成）
    __doc__ :类的文档字符串
    __class__: 类名
    __module__: 类定义所在的模块（类的全名是'__main__.className'，如果类位于一个导入模块mymod中，那么className.__module__ 等于 mymod）
    __bases__ : 类的所有父类构成元素（包含了一个由所有父类组成的元组）

20. is 判断两对象是否相同， ==判断值是否相同
21. 复数对象无法比较，会报异常错误。






