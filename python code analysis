第一章、python对象
1. Python的核心：一切皆对象
2. python中内建对象均是静态初始化的，一般来说类型对象是不能静态初始化的，也不能在栈空间上生存。
3. 定长对象与变长对象
4. PyObject：ob_refcnt+ob_type  PyVarObject：ob_refcnt+ob_size+ob_type，实际的内建对象会有一块维护的数据
5. 类型对象：ob_type，保留的是类的元信息，包括类名、大小等等，也是利用这个域实现多态性
6. 对象创建：AOL与COL两种，AOL是泛型编程，主要根据ob_type进行创建，COL是根据具体的类型直接创建。
7. 函数：内建函数大多也是泛型，通过ob_type进行关联调用。
8. 引用计数：通过引用计数进行垃圾回收，为了效率和空间创建了对象池计数

第二章、整数对象
1. 整数的实现是通过PyIntObject对象实现的，这里引入了另外一种对象的分类方式：可变（mutable）VS 不可变（inmutable），这里PyIntObject对象就是不可变的。其不变性指的是它维护的真实数值是不可变的，即一旦该对象被创建，那么它就不能再被改变值了。在python中整数对象其实就是对C的long类型的包装，多了一些类型的元信息（类型、大小、函数指针（第一张讲到这些函数也是一个个的对象，有点模板类的意思，根据函数指针获取ob_type调用对应的实例对象（这里抛出自定义类的函数指针对象***********************）））
2. 对象池：Python核心设计策略之一，从上面可以看到整数对象甚至是其他对象都是不可变的，那么面对众多的访问，就会造成python的瓶颈，因此对象池机制应运而生，几乎所有的内建对象都有自己的对象池机制。它将某个类型的诸多对象组合在一起，在解释器运行时即存在，直至解释器退出才会被注销。
3. 操作引出：整数的加减等操作返回的是一个新的对象。
4. Python 宏和函数：在Python中对某些频繁执行的函数提供了函数和宏两个版本，宏版本可以省去一次函数调用的开销，但是牺牲了类型安全。而函数版会多方检查类型安全性。
5. 对象的创建：第一章中讲过Python对象的创建有两种：C API 与类型对象PyInit_Type，其中C API又分为两类：泛型API AOL（模板型） 与类型相关API COL（只能作用在某一种类上），而类型对象的出现更过的是为了解决自定义类的问题，对于一个类A，Python不可能实现提供PyA_New这样的API（Python里面的对象都是静态创建的），Python会根据A的类型对象创建类对象（这里也抛出一个问题：A的类型对象是如何确定的？）。
   回到整数对象的创建：主要利用的是COL类型的API创建，PyInt_FromLong，PyInt_FromString，PyInt_FromUnicode三个接口，后两者实际就是先将字符串等对象转换为浮点数，然后在开勇PyInt_FromFloat，这实际就是适配器模式的实现。
   小整数对象：Python中所有对象都存活在系统堆上，而且是静态创建的，那么其创建方式就是malloc，而对于小整数对象会造成效率下降，因此就是使用了对象池技术。而受益于Python整数对象的不变性，所有的整数对象都可以被任意的共享，python中小整数为[-5,257]，这些小整数一开始就被创建缓存在内存里，使用时取出即可。
   大整数对象：考虑到时间和空间的问题，Python运行环境将提供一块内存空间轮流供大整数对象使用，谁需要谁使用，这样就避免了不断的malloc又考虑了内存。其具体实现是利用了PyIntBlock结构（单向列表），用于管理一定的python 整数对象，而多个block的组织也是通过链表。此外python会构建一个free_list管理所有的空前内存。Blcok开始只是一个数组最后转换为一个链表，其连接是利用P有Object的ob_type类型，但是这样就放弃了类型安全的坚持，不过也可以连接整数类型的派生类了。
   因此当新建整数对象时会先判断是否是小整数对象，然后选择合适的操作。
   当一个python整数对象被销毁时，它所占的内存不会被释放归还给系统，而是继续被python保存，变成自由内存，将来可供别的整数对象使用。但其实这样是python的一个漏洞，可以利用此漏洞吃完内存。 

第三章、字符串对象
1. 字符串对象也是一个不变对象，但是变长对象，因此它是不支持添加和删除操作的。此外它和C中相似，也是以\0结束，但是支持中间定义多个\0.字符串对象维护了一个ob_shash字段，初始为-1，用于保留hash值。此外ob_sstate表示该对象是否经过了intern机制处理，hash和intern使字符串在虚拟机上的执行效率提高了20%。
2. 空串：python保留了一个字符串对象nullstring用于处理空串，内部通过intern机制共享。
3. intern机制：python的intern机制保证在程序运行期间只有唯一的一个特定字符串存在，比如一个字符串为“ruby”，一旦经过intern，内部只会维持一个对象，当创建相同字符串对象时，实际是被引用了唯一的字符串。这样就可以节省内存。注意字符串的派生类是不会支持intern的。而intern的具体实现就是在系统中维护一个（key，value）的interned集合，记录着被intern处理的字符串对象，如果一个新的字符串可以在该集合中查找到，python会先为他创建一个对象，然后引用interned之后注销新创建的对象，实际就是一个temp对象。intern之后的对象有两种状态：第一种寿与天齐，第二种这是可以被注销的。
4. 字符缓冲池：给单字符创建了一个小的缓冲池，类似于小整数缓冲池。但不同的是小整数缓冲池是在python初始化创建的，而字符缓冲池则是以静态变量的形式存在的。字符缓冲池一开始是空的，如果有单字符创建，则会利用intern处理后放入缓冲池。
5. 效率问题：字符串的+操作是及其丑陋的操作，假设有多个字符串，它会两两合并，每次都要重新申请内存，因此建议使用join函数，它会先计算所有字符串的空间大小，然后统一申请合并。
