第一章、python对象
1. Python的核心：一切皆对象
2. python中内建对象均是静态初始化的，一般来说类型对象是不能静态初始化的，也不能在栈空间上生存。
3. 定长对象与变长对象
4. PyObject：ob_refcnt+ob_type  PyVarObject：ob_refcnt+ob_size+ob_type，实际的内建对象会有一块维护的数据
5. 类型对象：ob_type，保留的是类的元信息，包括类名、大小等等，也是利用这个域实现多态性
6. 对象创建：AOL与COL两种，AOL是泛型编程，主要根据ob_type进行创建，COL是根据具体的类型直接创建。
7. 函数：内建函数大多也是泛型，通过ob_type进行关联调用。
8. 引用计数：通过引用计数进行垃圾回收，为了效率和空间创建了对象池计数

第二章、整数对象
1. 整数的实现是通过PyIntObject对象实现的，这里引入了另外一种对象的分类方式：可变（mutable）VS 不可变（inmutable），这里PyIntObject对象就是不可变的。其不变性指的是它维护的真实数值是不可变的，即一旦该对象被创建，那么它就不能再被改变值了。在python中整数对象其实就是对C的long类型的包装，多了一些类型的元信息（类型、大小、函数指针（第一张讲到这些函数也是一个个的对象，有点模板类的意思，根据函数指针获取ob_type调用对应的实例对象（这里抛出自定义类的函数指针对象***********************）））
2. 对象池：Python核心设计策略之一，从上面可以看到整数对象甚至是其他对象都是不可变的，那么面对众多的访问，就会造成python的瓶颈，因此对象池机制应运而生，几乎所有的内建对象都有自己的对象池机制。它将某个类型的诸多对象组合在一起，在解释器运行时即存在，直至解释器退出才会被注销。
3. 操作引出：整数的加减等操作返回的是一个新的对象。
4. Python 宏和函数：在Python中对某些频繁执行的函数提供了函数和宏两个版本，宏版本可以省去一次函数调用的开销，但是牺牲了类型安全。而函数版会多方检查类型安全性。
5. 对象的创建：第一章中讲过Python对象的创建有两种：C API 与类型对象PyInit_Type，其中C API又分为两类：泛型API AOL（模板型） 与类型相关API COL（只能作用在某一种类上），而类型对象的出现更过的是为了解决自定义类的问题，对于一个类A，Python不可能实现提供PyA_New这样的API（Python里面的对象都是静态创建的），Python会根据A的类型对象创建类对象（这里也抛出一个问题：A的类型对象是如何确定的？）。
   回到整数对象的创建：主要利用的是COL类型的API创建，PyInt_FromLong，PyInt_FromString，PyInt_FromUnicode三个接口，后两者实际就是先将字符串等对象转换为浮点数，然后在开勇PyInt_FromFloat，这实际就是适配器模式的实现。
   小整数对象：Python中所有对象都存活在系统堆上，而且是静态创建的，那么其创建方式就是malloc，而对于小整数对象会造成效率下降，因此就是使用了对象池技术。而受益于Python整数对象的不变性，所有的整数对象都可以被任意的共享，python中小整数为[-5,257]，这些小整数一开始就被创建缓存在内存里，使用时取出即可。
   大整数对象：考虑到时间和空间的问题，Python运行环境将提供一块内存空间轮流供大整数对象使用，谁需要谁使用，这样就避免了不断的malloc又考虑了内存。其具体实现是利用了PyIntBlock结构（单向列表），用于管理一定的python 整数对象，而多个block的组织也是通过链表。此外python会构建一个free_list管理所有的空前内存。Blcok开始只是一个数组最后转换为一个链表，其连接是利用P有Object的ob_type类型，但是这样就放弃了类型安全的坚持，不过也可以连接整数类型的派生类了。
   注意小整数是共享的，但是大整数并不会。
   因此当新建整数对象时会先判断是否是小整数对象，然后选择合适的操作。
   当一个python整数对象被销毁时，它所占的内存不会被释放归还给系统，而是继续被python保存，变成自由内存，将来可供别的整数对象使用。但其实这样是python的一个漏洞，可以利用此漏洞吃完内存。 

第三章、字符串对象
1. 字符串对象也是一个不变对象，但是变长对象，因此它是不支持添加和删除操作的。此外它和C中相似，也是以\0结束，但是支持中间定义多个\0.字符串对象维护了一个ob_shash字段，初始为-1，用于保留hash值。此外ob_sstate表示该对象是否经过了intern机制处理，hash和intern使字符串在虚拟机上的执行效率提高了20%。
2. 空串：python保留了一个字符串对象nullstring用于处理空串，内部通过intern机制共享。
3. intern机制：python的intern机制保证在程序运行期间只有唯一的一个特定字符串存在，比如一个字符串为“ruby”，一旦经过intern，内部只会维持一个对象，当创建相同字符串对象时，实际是被引用了唯一的字符串。这样就可以节省内存。注意字符串的派生类是不会支持intern的。而intern的具体实现就是在系统中维护一个（key，value）的interned集合，记录着被intern处理的字符串对象，如果一个新的字符串可以在该集合中查找到，python会先为他创建一个对象，然后引用interned之后注销新创建的对象，实际就是一个temp对象。intern之后的对象有两种状态：第一种寿与天齐，第二种这是可以被注销的。
4. 字符缓冲池：给单字符创建了一个小的缓冲池，类似于小整数缓冲池。但不同的是小整数缓冲池是在python初始化创建的，而字符缓冲池则是以静态变量的形式存在的。字符缓冲池一开始是空的，如果有单字符创建，则会利用intern处理后放入缓冲池。
5. 效率问题：字符串的+操作是及其丑陋的操作，假设有多个字符串，它会两两合并，每次都要重新申请内存，因此建议使用join函数，它会先计算所有字符串的空间大小，然后统一申请合并。

第四章、list对象
1. python list对象类似于C++ 的vector对象，他是可变的，其定义如下：
   typedef struct {
     PyObject_VAR_HEAD; #存放元信息，ob_size表示存放了多少个元素
     PyObject **ob_item; # 指向元素列表的指针，可以看出他是PyObject类型的指针，也就是说可以存放任何python对象
     int allocated; #分配的元素个数， 可以看出其机制类似于Vector，不是用时才动态分配内存的。
   }PyListObject;
2. python创建list的途径只有一条----PyList_new。该函数接受size参数，允许创建时指定初始元素个数，创建时如果元素个数会溢出，那么停止创建，如果满足缓冲池的要求就使用缓冲池对象。如果不可用则在系统堆上申请内存，创建新的对象，此时还会为垃圾收集机制提供一些准备工作。注意list缓冲池最多维持80个对象。
3. list设置元素与插入元素的区别：及list[i] = var 与 list.insert(i,var)的区别，后者可能会使内存发生变化，因为List存放的元素不是一致的。插入操作实际是调用另外python内部的insl，它有一个条件就是对象必须有足够的内存来保证元素的插入，因此如果会超出内存就会调用resize函数。当newsize小于allocated且大于allocated的一半时简单调整ob_size的值，若小于一半则realloc收缩列表的内存空间。
4. 删除元素：一定会触发内存搬移操作，通过menmove来实现
5. 对象缓冲池：缓冲池对象实际来源于删除的list对象，一开始它是空的，等list对象销毁时会检查缓冲池是否已满及list对象是否在里面，若都没有则放入。

第五章、Dict对象
1. 不同于C++ map使用红黑树（查找o(lgn)）,python dict为了效率使用的是hash散列表，查找效率o(1),解决冲突的方法是开放定址法（二次探测函数）。
2. Dict对象中entry有三个状态：active、dummy（伪删除）、unused（key和value均为null），当记录被删除时不是直接被删除而是转为dummy，这样是为了防止探查链因此而中断。当python搜索到dummy时，会认为它虽然是无效的，但是其后面的元素还是有效的。
3. Dict中的key和value其实都是PyObject基类对象指向的。
4. 内部关联：Dict中维护ma_fill、ma_used、ma_mask、ma_table、ma_smalltable、ma_lookup，ma_fill是active+dummy记录个数，ma_used是active数量，ma_table指向一片entry的内存空间，如果记录数小于八，则使用ma_smalltable, ma_lookup是查找函数指针。
5. 对象创建：使用内部的PyDict_new接口创建，依旧使用了对象缓冲池。
6. 元素搜索：lookdict与lookdict_string两种，实际上算法是一致的，后者是前者的特殊情况。需要注意的是他们的返回结果永远是一个entry而不是null，如果搜索不到那么返回的entry 的value为null。搜索是会比较两种相同：值相同、引用相同（引用的内存地址相同），先比较后者再比较前者，只要相同就停止搜索。当搜索到dummy或unused时需要完整的设置hash、key、value
7. 缓冲池：与PyList的机制一样。


第六章、python的编译结果
1. python是解释性的语言：这句话是不对的，它和java等没有太大区别，总体也是分为虚拟机、字节码两个部分。虚拟机的执行原理都是一样的，但是python虚拟机的抽象层次更深，离真实机器更远。
   python执行过程：py文件---->虚拟机编译---->pyc文件---->虚拟机执行---->执行结果，windows下虚拟机为pythonXX.dll,linux下为bin文件
   java执行过程：.java文件---->javac编译---->.class字节码文件---->调用java命令执行---->执行结果。
2. pyc: PyCodeObject对象，编译完成后结果会保存在pyCodeObject对象中，执行结束后保存到pyc文件中，下次执行时如果没有改动源文件那么久从pyc文件直接重建pycodeobject对象。那么编译出来的东西有哪些呢？主要有字节码、（字符串、常量等对字节码有用的信息）




