1. builtins functions:
   1) abs、all、any、ascii、bin(x)[转为二进制]、callable、compile(source, filename, mode, flags=0, dont_inherit=False, optimize=-1)、delattr、setattr、getattr、hasattr、hash、hex、divmod(a,b)[返回商，余数的tuple]、enumerate[返回的是枚举类型，有__next__方法]、eval(expression, globals=None, locals=None)、exec、id、input、isinstance、insubclass、len、iter、max、min、next(iter)、open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)、pow(x, y[, z])[z表示将结果对z求余数]、range(start, stop[, step])、reverse(seq)、round()、sum、tuple、type、zip、__import__(name, globals=None, locals=None, fromlist=(), level=0)
   2) class对象：bool、bytearray、bytes[不可变对象]、complex([real[, imag]])、dict、float、int、list、object、set
   3) @classmethod ：将函数转为类方法，一般在类内定义的方法都只能用对象来调用，加上它可用类名调用也可以用对象调用,它是一个包装器
      class C(object):
          @classmethod
          def f()...
   4) chr(x)[转为单字符]:x是整数  与之相反的是ord(x):将字符x转为数字，oct(x)：将整数转为8进制字符串
   5) dir([object]): 如果没有参数则返回局部作用域的属性，否则返回对象的属性，如果对象有定义的__dir__()方法将第一时间被调用，其尝试用__getattr__或者__getattribute__等自定义方法获取属性。如果没有__dir__则访问__dict__属性。
   6) globals()返回全局域的符号dict、locals()返回当前局部域的符号dict。
   7) help(object):可以查看对象的帮助信息，交互环境下debug很有用。
   8) filter、map：filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。注意到filter()函数返回的是一个Iterator，也就是一个惰性序列，所以要强迫filter()完成计算结果，需要用list()函数获得所有结果并返回list。map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。同样也要用list()强制计算。
   9) memoryview(obj)：查看对象的内存情况，具体查看memory view模块。
   10) print(*objects, sep=' ', end='\n', file=sys.stdout, flush=False)：注意分割符、尾符、文件、刷新的选择。
   11) class property(fget=None, fset=None, fdel=None, doc=None):意为属性的属性，假设类A有属性x，有方法getx、delx、setx，在类内使用x = property(getx,setx,delx,"this is property of x"), 或者作为修饰器将某个方法的访问方式改成属性方式，它还有setter、gettter、delter等包装器
       @property
       def f()....    访问class.f
   12) repr(object)、类对象能够通过自己的__repr__()方法控制外部repr的输出。str与repr、__str__与__repr__区别在于缺省实现是没用的，__repr__的目标是准确性，__str__的目标是可读性，容器的__str__使用包含了对象的__repr__
   13) @staticmethod: 将类函数转为静态函数，是一个包装器。
   14）super() 函数是用于调用父类(超类)的一个方法。super 是用来解决多重继承问题的，直接用类名调用父类方法在使用单继承的时候没问题，但是如果使用多继承，会涉及到查找顺序（MRO）、重复调用（钻石继承）等种种问题。super([type[, object-or-type]])
   15）vars:返回对象的__dict__属性
